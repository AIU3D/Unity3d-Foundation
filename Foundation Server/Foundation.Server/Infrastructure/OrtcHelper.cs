using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Foundation.Server.Infrastructure
{
    /// <summary>
    /// The channel permission.
    /// </summary>
    public enum ChannelPermissions
    {
        /// <summary>
        /// Read permission
        /// </summary>
        Read = 'r',

        /// <summary>
        /// Read and Write permission
        /// </summary>
        Write = 'w',

        /// <summary>
        /// Presence permission
        /// </summary>
        Presence = 'p'
    }

    /// <summary>
    /// ORTC server side API that contains ORTC factories as plug-ins.
    /// </summary>
    public class OrtcHelper
    {

        #region Post Authentication

        /// <summary>
        /// Gets the cluster server.
        /// </summary>
        /// <returns></returns>
        public static async Task<string> GetClusterServer(string url, String applicationKey)
        {
            const string ResponsePattern = "var SOCKET_SERVER = \"(?<host>.*)\";";

            var clusterRequestParameter = !String.IsNullOrEmpty(applicationKey) ? String.Format("appkey={0}", applicationKey) : String.Empty;
            var clusterUrl = String.Format("{0}{1}?{2}", url, !String.IsNullOrEmpty(url) && url[url.Length - 1] != '/' ? "/" : String.Empty, clusterRequestParameter);


            var client = new HttpClient();
            //client.Accept = "application/x-www-form-urlencoded";
            var response = await client.GetStringAsync(new Uri(clusterUrl));

            var match = Regex.Match(response, ResponsePattern);

            return match.Groups["host"].Value;
        }


        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">Authentication Token which is generated by the application server, for instance a unique session ID.</param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static async Task<HttpResponseMessage> PostAuthentication(string authenticationToken, bool authenticationTokenIsPrivate,
            string applicationKey, int timeToLive, string privateKey, Dictionary<string, string[]> permissions)
        {
            var url = "http://ortc-developers.realtime.co/server/2.1";
            bool isCluster = true;

            var connectionUrl = url;

            if (isCluster)
            {
                connectionUrl = await GetClusterServer(url, applicationKey);
            }

            connectionUrl = connectionUrl[connectionUrl.Length - 1] == '/' ? connectionUrl : connectionUrl + "/";


            var postParameters = String.Format("AT={0}&PVT={1}&AK={2}&TTL={3}&PK={4}", authenticationToken, authenticationTokenIsPrivate ? 1 : 0, applicationKey, timeToLive, privateKey);

            if (permissions != null && permissions.Count > 0)
            {
                postParameters += String.Format("&TP={0}", permissions.Count);
                foreach (var permission in permissions)
                {
                    var permissionItemText = String.Format("{0}=", permission.Key);
                    var list = new List<string>(permission.Value);
                    foreach (var permissionItemValue in list)
                    {
                        permissionItemText += permissionItemValue;
                    }

                    postParameters += String.Format("&{0}", permissionItemText);
                }
            }
            var uri = new Uri(String.Format("{0}authenticate", connectionUrl));

            var client = new HttpClient();

            return await client.PostAsync(uri, new StringContent(postParameters));
        }

        #endregionÂ Methods
    }
}